---
layout: default
title: "静态单赋值"
nav_order: 10
parent: Toy Tutorial
grand_parent: Tutorial教程
---

> 来源：[静态单一赋值 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/57787118)

在编译器设计中，静态单一赋值形式（通常缩写为SSA形式或简称SSA）是中间表示（IR）的属性，它要求每个变量只分配一次，并且每个变量在使用之前定义。原始IR中的现有变量被拆分为版本，在教科书中，新变量通常由原始名称用下标表示，以便每次定义都有自己的版本。在SSA形式中，use-def链是显式的，每个包含一个元素。

SSA由Barry K. Rosen、Mark N. Wegman和F. Kenneth Zadeck于1988年提出【1】。IBM的前三位研究人员Ron Cytron、Jeanne Ferrante和开发了一种算法，可以有效地计算SSA形式【2】。

SSA的主要用途来自于它如何通过简化变量的属性来，同时简化和改进各种编译器优化的结果。 例如，考虑这段代码：

```c
 y := 1
 y := 2
 x := y
```

可以看到第一个赋值不是必需的，并且第三行中使用的y的值来自y的第二个赋值。 程序必须执行到达定义分析（reading definition analysis）以确定这一点。 但如果该程序采用SSA形式，则两者都是显而易见的：

```c
y1 := 1
y2 := 2
x1 := y2
```

通过使用SSA可以实现或增强效果的编译器优化算法包括：

- 常量传播
- 值范围传播[3]
- 稀疏条件常数传播
- 死代码消除
- 全局值编号
- 部分冗余消除
- 强度减少
- 注册分配

将普通代码转换为SSA形式主要是用新变量替换每个赋值的目标，并将变量的每个用法替换为到达该点的变量的“版本”。 例如，请考虑以下控制流程图：

![img](https://shichen-picgo.oss-cn-chengdu.aliyuncs.com/img/v2-41dae232180778d0cb9c83e7f5e4f279_b.jpg)

更改“ x←x−3 ”左侧的名称，并将 x 的以下用法更改为该新名称将使程序保持不变。 这可以在SSA中通过创建两个新变量来利用： x1 和 x2 ，每个变量只分配一次。 同样，为所有其他变量提供可区分的下标产生：

![img](https://shichen-picgo.oss-cn-chengdu.aliyuncs.com/img/v2-b8367375250b389dbed87c56c28cae70_b.jpg)

这样，就很清楚变量的每次使用所值的定义，除了一种情况：底部块中 y 的两个使用都可以指 y1 或 y2 ，这取决于控制流采用的路径。

要解决此问题，会在最后一个块中插入一个特殊语句，称为 **Φ (phi)函数**。 该语句将通过“选择” y1 或 y2 生成 y 的新定义，称为 y3 ，具体取决于过去的控制流程。

现在，最后一个块可以简单地使用 y3 ，并且将以任一方式获得正确的值。不需要x的Φ函数：因为 x 只有一个版本，即 x2 到达这个位置（换句话说，Φ（x2，x2）= x2）。

给定任意控制流程图，可能很难分辨插入Φ函数的位置以及哪些变量。这个一般性问题有一个有效的解决方案，可以使用一个称为优势边界的概念来计算（见下文）。

在大多数机器上并没有实现 Φ 函数为机器操作。<u>编译器可以简单地通过在内存（或相同的寄存器）中使用与产生Φ功能的输入的任何操作的目的地相同的位置来实现Φ功能</u>。然而，当并行操作推测性地产生对Φ功能的输入时，这种方法不起作用，如在wide-issue机器上可能发生的那样。通常，wide-issue机器具有由编译器在这种情况下用于实现Φ功能的选择指令。